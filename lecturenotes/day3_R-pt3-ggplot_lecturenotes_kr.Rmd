---
title: "Intro to R: Day 1"
author: "Kumar Ramanathan"
date: "`r Sys.Date()`"
output: 
  html_document:
    toc: true
    toc_float: true
    toc_depth: 3
params:
  notes: no
---


```{r setup, include=FALSE}
knitr::opts_knit$set(root.dir = normalizePath("../"))
knitr::opts_chunk$set(echo = TRUE, warning = FALSE)
```

```{r, include=FALSE}
notes<-params$notes
```

# Introduction to ggplot

## What is ggplot?

The `ggplot2` package is part of `tidyverse`, a suite of packages maintained by the RStudio company. In ggplot, graphics are built in ggplot by supplying *data* and *aesthetic mapping*, and then adding *layers* that build geometries, scales, coordinate systems, and more using the provided data and mapping.

Before using ggplot, make sure to load the package. You can either load `tidyverse` or `ggplot2` directly.

```{r}
library(tidyverse)
```

## Why ggplot?

- It is highly customizable and extensible.
- It is designed to work well in conjunction with `dplyr` and other `tidyverse` packages.
- It has been in usage for over 10 years, meaning that help is widely available.
- Its wide usage has also given rise to a wide variety of avilable [extensions](http://www.ggplot2-exts.org/gallery/), including those that handle create interactive graphics (`ggigraph`), animated graphics (`gganimate`), alluvial diagrams (`ggalluvial`), maps (`ggmap`), and more.

## Some useful resources

- The [ggplot cheatsheet](https://github.com/rstudio/cheatsheets/blob/master/data-visualization-2.1.pdf) maintained by RStudio is an invaluable resource. I always have it open when using `ggplot2`.
- The [ggplot reference sheet](https://ggplot2.tidyverse.org/reference/index.html) maintained by RStudio. In your early days using `ggplot2`, this will be more useful in conjunction with the cheatsheet since it contains more detail on syntax and links to full help files. 
- The [Data Visualization chapter](http://r4ds.had.co.nz/data-visualisation.html) in the R for Data Science book by Garrett Grolemund and Hadley Wickham. The rest of the book explores other parts of the `tidyverse`.
- [ggedit](https://github.com/metrumresearchgroup/ggedit) is an extension package for `ggplot2` that enables users to launch an graphical user interface (GUI) with which to build ggplot graphics layer-by-layer. When completed, the user can copy the code required to generate the plot and return to their script file. 
    - There is [some controversy](https://www.youtube.com/watch?v=cpbtcsGE0OA) over whether GUIs diminish creativity and flexibility in data science, but nevertheless, this tool may help early learners get used to the grammar of ggplot.
- And, of course, the help files that come with the package itself.

# Basics: the grammar of graphics

ggplot works by combining several functions using the `+` operator. You can start a new line after each `+` operator for readability if you would like (I do so throughout these notes.) Each function does something specific: provide a dataset, create a geometric object, add labels, add scales, change the coordinate system or layout, change the color palette, etc. 

Each graphic generated by ggplot requires at least three basic components:

- **data**: a data frame containing the data that you want to visualize, provided in the `ggplot()` function's required `data = ` argument.
- **geometric objects**: the objects/shapes that you want to plot, indicated through one of the many available `geom` functions, such as `geom_point()` or `geom_hist()`.
- **aesthetic mapping**: the mapping from the data to the geometric objects, provided in an `aes()` function nested within the `mapping = ` argument of the `geom` function. 
    - You can also provide the `aes()` function to the `mapping = ` argument of `ggplot()`. If you do so, *all* `geom` functions will pull from the aesthetic mapping provided in this initial `ggplot()` function.

Together, the basic structure looks like this:

```{r ggplot structure, eval=F}
ggplot(data = <DATA FRAME>) + 
  <GEOM_FUNCTION>(mapping = aes(<VARIABLES>))
```

To demonstrate with an example, let's re-create the scatterplot we made in Day 1 using data from Gapminder. Recall that we used the 2007 data subset and plotted the relationship between life expectancy on the y-axis and GDP per capita on the x-axis. Using the structure above, we would proceed as follows:

1. Provide the data in the `data = ` argument of the initial `ggplot()` function. 
2. Select `geom_point()` as our second function, since the geometric object we want to generate is points. 
3. Within the `mapping = ` argument of `geom_point()`, we provide our aesthetic mapping. In this case, we need to provide an `x` and `y` variable for the points. 

Altogether, it looks like this:

```{r scatterplot 1}
ggplot(data = gapminder07) + 
  geom_point(mapping = aes(x = gdpPercap, y = lifeExp))
```

Recall how we added a horizontal line to the scatterplot on Day 1. We can replicate that in ggplot by adding another layer using the `geom_hline()` function, which generates another geometric object (specifically, a horizontal line). Notice that `data = ` and `mapping = ` have been dropped here: as with all functions in R, since these are the first arguments, R assumes that the first inputs provided to the function are for these first arguments.

```{r scatterplot 2}
ggplot(gapminder07) + 
  geom_point(aes(x = gdpPercap, y = lifeExp)) + 
  geom_hline(aes(yintercept = mean(lifeExp)))
```

We can also add titles and axes as a layer using the `labs()` function.

```{r scatterplot 3}
ggplot(data = gapminder07) + 
  geom_point(aes(x = gdpPercap, y = lifeExp)) + 
  geom_hline(aes(yintercept = mean(lifeExp))) + 
  labs(title = "Relationship between life expectancy and GDP per capita in 2007", 
       x = "GDP per capita", y = "Life expectancy")
```

As you can see, the grammar of graphics used in ggplot2 breaks down the information that goes into each graphic into several layers, each of which you can customize.

# Preparing your data

Recall the role of pipes (`%>%`) in `dplyr` this morning. Since `dplyr` and `ggplot2` are both part of tidyverse, they are designed to work well together. You can use a series of pipes to prepare your data to be in the appropriate format, subset, etc before plotting.

For example, consider the above plot. Instead of specifying the data in the `ggplot()` function, we can supply the data through a pipe. Instead of using the subsetted `gapminder07` data, we can use the original `gapminder5` and use a `filter()` function to select the 2007 observations only.

```{r data prep 1}
gapminder5 %>% 
  filter(year == 2007) %>% 
  ggplot() + 
  geom_point(aes(x = gdpPercap, y = lifeExp)) + 
  geom_hline(aes(yintercept = mean(lifeExp))) + 
  labs(title = "Relationship between life expectancy and GDP per capita in 2007", 
       x = "GDP per capita", y = "Life expectancy")
```

For another example of preparing data for plotting, let's turn to the California energy data, which we will use for the rest of the ggplot session. Recall that in the first session of Day 3, you created a long-format data frame containing data on all energy generated during September 3-9, called `long_gen`. Say we wanted to visualize the total energy generated in the state over time. By using `group_by()` and `summarize()`, we can sum the output for each date-time value (i.e. each hour) and feed this directly into `ggplot()`. Note that this kind of graphing task is one of the uses of having a long-format version of your data.

```{r data prep 2}
long_gen %>% 
  group_by(datetime) %>% 
  summarise(output=sum(output)) %>% 
  ggplot() + 
  geom_col(aes(x=datetime, y=output)) + 
  labs(title="Total energy generated, by hour", x="Hour", y="Output (MW)")
```

Perhaps we are concerned that the above plot has too much granularity. Instead, we want to plot the total output per *day* instead of per *hour*. Again, we can achieve this by manipulating our data prior to piping it into `ggplot()`. Note that we use the `date()` function in `lubridate` which takes a date-time value and returns the date portion only.

```{r data prep 3}
long_gen %>% 
  mutate(date=lubridate::date(datetime)) %>% 
  group_by(date) %>% 
  summarise(output=sum(output)) %>% 
  ggplot() + 
  geom_col(aes(x=date, y=output)) + 
  labs(title="Total energy generated, by day", x="Day", y="Output (MW)")
```

# Geometric objects

We have already seen two kinds of geometries: `geom_point()` which generates points using `x` and `y` values, and `geom_col()` which generates columns for a bar chart. Let's explore a few more, and learn how to modulate the appearance of the geometric objects created.

## Line plot

Let's say we'd like to plot the amount of energy imported over time. We can use `geom_line` to generate a line connecting all the data points. To do so, we need to provide `x` and `y` values in the aesthetic mapping function nested within `geom_line()`. Note that we are using the `imports` data frame here, but we could easily use the wide- or long-format merged data frames, as long as we use the appropriate filtering functions.

```{r geom_line}
imports %>%
  ggplot() + 
  geom_line(aes(x=datetime, y=imports)) + 
  labs(title="Energy imports over time", x="Hour", y="Amount imported (MW)")
```

## Changing size and color

Once we have created the geometric object we want, using the appropriate aesthetic mapping, we may want to change the appearance of the object. The features that we can modify vary depending on the `geom` object (the cheatsheet and each function's reference files are helpful here). For most function, we can modify the size and shape of the object(s) created. Let's try to increase the size of the line in the plot above and make it red in color. Note that the `col = ` and `size = ` arguments here are *outside* the `aes()` function since we are not mapping anything from the data frame here.

```{r geom_line}
imports %>%
  ggplot() + 
  geom_line(aes(x=datetime, y=imports), size=1.2, col="red") + 
  labs(title="Energy imports over time", x="Hour", y="Amount imported (MW)")
```

To learn more about the color inputs you can provide in R, see the [R colors cheatsheet](https://www.nceas.ucsb.edu/~frazier/RSpatialGuides/colorPaletteCheatsheet.pdf). 

## Area plot

```{r area plot}
long_gen %>% 
  group_by(source) %>% 
  
```

## Box plot

```{r box plot}
long_gen %>% 
  ggplot() + 
  geom_boxplot(aes(x=source, y=output)) + 
  labs(title="Amount of energy generated by each source", x="Source type", y="Output (MW)")
```

## Multiple geometries in one plot

```{r multiple geoms}
merged_energy %>%
  ggplot() + 
  geom_line(aes(x=datetime, y=large_hydro)) + 
  geom_smooth(aes(x=datetime, y=large_hydro)) 
```

## Other geometric objects

There are many, many more geometric objects that you can create using ggplot. For a full list, see the cheatsheet and reference guide linked above. Several extension packages add even more geometric objects.

# Additional layers

## Stats

## Scales

## Labels

## Themes

## Legends

## Coordinate system adjustment

# Visualizing grouped data

Throughout these examples, you will see one of the uses of converting data to long-format. Doing so allows us to plot multiple variables in one graphic using a single `geom` function, providing the key column as the grouping variable. 

## Colors and fill

Although ggplot will generally interpret a `col = ` argument as providing a grouping variable, it is good practice to specify `group = ` anyway. 

```{r aes colors}

```

Let's take a look at a more complex plot that uses grouping to generate multiple lines. This plot shows the average output of each energy source by hour. Instead of describing the process in detail here, comments are included throughout the code itself. Note how the code for this plot combines several of the topics we have discussed so far (data manipulation before plotting, scales, themes, and labels).

```{r aes colors 2}
long_merged_energy %>% 
  # Create a variable indicating hour only
  mutate(hour=lubridate::hour(datetime)) %>% 
  # Group data by hour and source
  group_by(hour, source) %>% 
  # Compute mean output for each hour-source unit
  summarise(output=mean(output)) %>% 
  # Pipe data into ggplot
  ggplot() + 
  # Plot lines for output over hour, grouped by source
  geom_line(aes(x=hour, y=output, group=source, col=source), size=1) + 
  # Use Set3 color palette to distinguish lines from each other
  scale_color_brewer(palette="Set3") + 
  # Use dark theme to make colors more visible + 
  theme_dark() + 
  # Add labels
  labs(title="Average hourly output of each energy source", x="Hour", y="Mean output (MW)")
```

Using the color aesthetic to demarcate groups is meaningful for functions like `geom_point()` and `geom_line()`. For functions like `geom_col()` and `geom_area()`, specifying the `col = ` arugment will create an outline around the object (try it out and see for yourself). If we want to color the entire object, we specify the `fill = ` argument instead.

```{r aes fill}

```

## Shapes and linetypes

```{r aes shapes}

```

```{r aes linetypes}

```

## Position adjustment

```{r pos dodge}

```

```{r pos stack}

```

## Facets

Let's say we are interested in examining hour-by-hour generation data by source. Using the position adjustment skills we learned in the previous subsection, we can generate a line plot as follows.

```{r why facet}
long_merged_energy %>% 
  filter(source!="imports") %>%
  ggplot() + 
  geom_line(aes(x=datetime, y=output, group=source, col=source, position="dodge"), size=1) + 
  labs(title="Generation over time, by energy source", x="Hour", y="Output")
```

```{r facet 1}
long_merged_energy %>% 
  filter(source!="imports") %>%
  ggplot() + 
  geom_line(aes(x = datetime, y = output)) + 
  facet_wrap(.~source)
```

```{r facet 2}
long_merged_energy %>% 
  filter(source!="imports") %>%
  ggplot() + 
  geom_line(aes(x = datetime, y = output)) + 
  facet_wrap(.~source, scales="free") + 
  labs(title = "Generation over time, Sep 3-9", x = "Hour", y = "Output")
```

```{r facet 3}
regroup <- readr::read_csv("data/regroup.csv")
regroup %>% 
  # Rename "type" variable in regroup to "source"
  rename(source = type) %>%
  # Merge energy data with regroup data by "source" variable
  merge(long_merged_energy, by = "source") %>% 
  # Filter out imports data
  filter(source!="imports") %>%
  # Pipe data into dplyr
  ggplot() + 
  # Generate lines indicating output ~ time, colored based on "group" variable
  geom_line(aes(x = datetime, y = output, col=group)) + 
  # Create facets by source, with free scales
  facet_wrap(.~source, scales="free") + 
  # Add labels
  labs(title = "Generation over time, Sep 3-9", x = "Hour", y = "Output") + 
  # Use the minmal theme
  theme_minimal() + 
  # Move the legend to the bottom
  theme(legend.position = "bottom")
```

# Final notes

## Comment your code

## Saving images

## Explore available extensions