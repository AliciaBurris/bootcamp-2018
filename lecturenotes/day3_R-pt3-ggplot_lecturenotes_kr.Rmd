---
title: "Intro to R: Day 1"
author: "Kumar Ramanathan"
date: "`r Sys.Date()`"
output: 
  html_document:
    toc: true
    toc_float: true
    toc_depth: 3
params:
  notes: no
---


```{r setup, include=FALSE}
knitr::opts_knit$set(root.dir = normalizePath("../"))
knitr::opts_chunk$set(echo = TRUE, warning = FALSE)
```

```{r, include=FALSE}
notes<-params$notes
```

# Introduction to ggplot

## What is ggplot?

The `ggplot2` package is part of `tidyverse`, a suite of packages maintained by the RStudio company. In ggplot, graphics are built in ggplot by supplying *data* and *aesthetic mapping*, and then adding *layers* that build geometries, scales, coordinate systems, and more using the provided data and mapping.

Before using ggplot, make sure to load the package. You can either load `tidyverse` or `ggplot2` directly.

```{r}
library(tidyverse)
```

## Why ggplot?

- It is highly customizable and extensible.
- It is designed to work well in conjunction with `dplyr` and other `tidyverse` packages.
- It has been in usage for over 10 years, meaning that help is widely available.
- Its wide usage has also given rise to a wide variety of avilable [extensions](http://www.ggplot2-exts.org/gallery/), including those that handle create interactive graphics (`ggigraph`), animated graphics (`gganimate`), alluvial diagrams (`ggalluvial`), maps (`ggmap`), and more.

## Some useful resources

- The [ggplot cheatsheet](https://github.com/rstudio/cheatsheets/blob/master/data-visualization-2.1.pdf) maintained by RStudio is an invaluable resource. I always have it open when using `ggplot2`.
- The [ggplot reference sheet](https://ggplot2.tidyverse.org/reference/index.html) maintained by RStudio. In your early days using `ggplot2`, this will be more useful in conjunction with the cheatsheet since it contains more detail on syntax and links to full help files. 
- The [Data Visualization chapter](http://r4ds.had.co.nz/data-visualisation.html) in the R for Data Science book by Garrett Grolemund and Hadley Wickham. The rest of the book explores other parts of the `tidyverse`.
- [ggedit](https://github.com/metrumresearchgroup/ggedit) is an extension package for `ggplot2` that enables users to launch an graphical user interface (GUI) with which to build ggplot graphics layer-by-layer. When completed, the user can copy the code required to generate the plot and return to their script file. 
    - There is [some controversy](https://www.youtube.com/watch?v=cpbtcsGE0OA) over whether GUIs diminish creativity and flexibility in data science, but nevertheless, this tool may help early learners get used to the grammar of ggplot.
- And, of course, the help files that come with the package itself.

# Basics: the grammar of graphics

ggplot works by combining several functions using the `+` operator. You can start a new line after each `+` operator for readability if you would like (I do so throughout these notes.) Each function does something specific: provide a dataset, create a geometric object, add labels, add scales, change the coordinate system or layout, change the color palette, etc. 

Each graphic generated by ggplot requires at least three basic components:

- **data**: a data frame containing the data that you want to visualize, provided in the `ggplot()` function's required `data = ` argument.
- **geometric objects**: the objects/shapes that you want to plot, indicated through one of the many available `geom` functions, such as `geom_point()` or `geom_hist()`.
- **aesthetic mapping**: the mapping from the data to the geometric objects, provided in an `aes()` function nested within the `mapping = ` argument of the `geom` function. 
    - You can also provide the `aes()` function to the `mapping = ` argument of `ggplot()`. If you do so, *all* `geom` functions will pull from the aesthetic mapping provided in this initial `ggplot()` function.

Together, the basic structure looks like this:

```{r ggplot structure, eval=F}
ggplot(data = <DATA FRAME>) + 
  <GEOM_FUNCTION>(mapping = aes(<VARIABLES>))
```

To demonstrate with an example, let's re-create the scatterplot we made in Day 1 using data from Gapminder. Recall that we used the 2007 data subset and plotted the relationship between life expectancy on the y-axis and GDP per capita on the x-axis. Using the structure above, we would proceed as follows:

1. Provide the data in the `data = ` argument of the initial `ggplot()` function. 
2. Select `geom_point()` as our second function, since the geometric object we want to generate is points. 
3. Within the `mapping = ` argument of `geom_point()`, we provide our aesthetic mapping. In this case, we need to provide an `x` and `y` variable for the points. 

Altogether, it looks like this:

```{r scatterplot 1}
ggplot(data = gapminder07) + 
  geom_point(mapping = aes(x = gdpPercap, y = lifeExp))
```

Recall how we added a horizontal line to the scatterplot on Day 1. We can replicate that in ggplot by adding another layer using the `geom_hline()` function, which generates another geometric object (specifically, a horizontal line). Notice that `data = ` and `mapping = ` have been dropped here: as with all functions in R, since these are the first arguments, R assumes that the first inputs provided to the function are for these first arguments.

```{r scatterplot 2}
ggplot(gapminder07) + 
  geom_point(aes(x = gdpPercap, y = lifeExp)) + 
  geom_hline(aes(yintercept = mean(lifeExp)))
```

We can also add titles and axes as a layer using the `labs()` function.

```{r scatterplot 3}
ggplot(data = gapminder07) + 
  geom_point(aes(x = gdpPercap, y = lifeExp)) + 
  geom_hline(aes(yintercept = mean(lifeExp))) + 
  labs(title = "Relationship between life expectancy and GDP per capita in 2007", 
       x = "GDP per capita", y = "Life expectancy")
```

As you can see, the grammar of graphics used in ggplot2 breaks down the information that goes into each graphic into several layers, each of which you can customize.

# Preparing your data

Recall the role of pipes (`%>%`) in `dplyr` this morning. Since `dplyr` and `ggplot2` are both part of tidyverse, they are designed to work well together. You can use a series of pipes to prepare your data to be in the appropriate format, subset, etc before plotting.

For example, consider the above plot. Instead of specifying the data in the `ggplot()` function, we can supply the data through a pipe. Instead of using the subsetted `gapminder07` data, we can use the original `gapminder5` and use a `filter()` function to select the 2007 observations only.

```{r data prep 1}
gapminder5 %>% 
  filter(year == 2007) %>% 
  ggplot() + 
  geom_point(aes(x = gdpPercap, y = lifeExp)) + 
  geom_hline(aes(yintercept = mean(lifeExp))) + 
  labs(title = "Relationship between life expectancy and GDP per capita in 2007", 
       x = "GDP per capita", y = "Life expectancy")
```

For another example of preparing data for plotting, let's turn to the California energy data, which we will use for the rest of the ggplot session. Recall that in the first session of Day 3, you created a long-format data frame containing data on all energy generated during September 3-9, called `long_gen`. Say we wanted to visualize the total energy generated in the state over time. By using `group_by()` and `summarize()`, we can sum the output for each date-time value (i.e. each hour) and feed this directly into `ggplot()`. Note that this kind of graphing task is one of the uses of having a long-format version of your data.

```{r data prep 2}
long_gen %>% 
  group_by(datetime) %>% 
  summarise(output=sum(output)) %>% 
  ggplot() + 
  geom_col(aes(x=datetime, y=output)) + 
  labs(title="Total energy generated, by hour", x="Hour", y="Output (MW)")
```

Perhaps we are concerned that the above plot has too much granularity. Instead, we want to plot the total output per *day* instead of per *hour*. Again, we can achieve this by manipulating our data prior to piping it into `ggplot()`. Note that we use the `date()` function in `lubridate` which takes a date-time value and returns the date portion only.

```{r data prep 3}
long_gen %>% 
  mutate(date=lubridate::date(datetime)) %>% 
  group_by(date) %>% 
  summarise(output=sum(output)) %>% 
  ggplot() + 
  geom_col(aes(x=date, y=output)) + 
  labs(title="Total energy generated, by day", x="Day", y="Output (MW)")
```

# Geometric objects

We have already seen two kinds of geometries: `geom_point()` which generates points using `x` and `y` values, and `geom_col()` which generates columns for a bar chart. Let's explore a few more, and learn how to modulate the appearance of the geometric objects created.

## Line plot

Let's say we'd like to plot the amount of energy imported over time. We can use `geom_line` to generate a line connecting all the data points. To do so, we need to provide `x` and `y` values in the aesthetic mapping function nested within `geom_line()`. Note that we are using the `imports` data frame here, but we could easily use the wide- or long-format merged data frames, as long as we use the appropriate filtering functions.

```{r geom_line}
imports %>%
  ggplot() + 
  geom_line(aes(x=datetime, y=imports)) + 
  labs(title="Energy imports over time", x="Hour", y="Amount imported (MW)")
```

## Changing size and color

Once we have created the geometric object we want, using the appropriate aesthetic mapping, we may want to change the appearance of the object. The features that we can modify vary depending on the `geom` object (the cheatsheet and each function's reference files are helpful here). For most function, we can modify the size and shape of the object(s) created. Let's try to increase the size of the line in the plot above and make it red in color. Note that the `col = ` and `size = ` arguments here are *outside* the `aes()` function since we are not mapping anything from the data frame here.

```{r geom_line size and color}
imports %>%
  ggplot() + 
  geom_line(aes(x=datetime, y=imports), size=1.2, col="red") + 
  labs(title="Energy imports over time", x="Hour", y="Amount imported (MW)")
```

To learn more about the color inputs you can provide in R, see the [R colors cheatsheet](https://www.nceas.ucsb.edu/~frazier/RSpatialGuides/colorPaletteCheatsheet.pdf). 

## Area plot

In addition to lines and columns, we can also generate an area plot with `geom_area()`. Let's try it with a plot of wind power generation over time. Note that to change the color on this plot, we use `fill = ` rather than `col = `. This is because we want to *fill* the geometric object with a color; using `col = ` would create an outline around the plot (try it out to see the difference). Also note that 

```{r area plot}
generation %>% 
  ggplot() + 
  geom_area(aes(x=datetime, y=wind), fill="darkblue") + 
  labs(title="Hourly wind power generation, Sept 3-9", x="Hour", y="Output (MW)")
```

## Box plot

Let's explore one more plot that visualizes a different kind of relationship. Instead of plotting trends over time, let's plot the distribution of each source's output using a box plot (aka a box-and-whisker plot) which shows the 25% quantile, mean, and 50% quantile in a "box" and the minimum and maximum values in "whiskers". We can do so using the function `geom_boxplot()`; note again that this is a case where having long-format data is useful.

```{r box plot}
long_gen %>% 
  ggplot() + 
  geom_boxplot(aes(x=source, y=output)) + 
  labs(title="Amount of energy generated by each source, Sept 3-9", x="Source type", y="Output (MW)")
```

## Multiple geometries in one plot

The above examples show cases where one geometric object is plotted per graphic. `ggplot` allows you to add multiple geometric objects as layers. Below is a plot of large hydro power generation over time, first shown using a line with `geom_line()`. On top of that line plot, we can also add a smoothed line with `geom_smooth()`, which plots smoothed conditional means (estimated using a loess regression) in order to aid observation of trends in cases of overplotting.

```{r multiple geoms}
merged_energy %>% 
  ggplot() + 
  geom_line(aes(x=datetime, y=large_hydro), col="turquoise3") + 
  geom_smooth(aes(x=datetime, y=large_hydro)) + 
  labs(title="Hydroelectric (large) generation per hour, Sept 3-9", x="Hour", y="Output (MW)")
```

An alternative syntax is to do the aesthetic mapping in the `ggplot()` function, after which all `geom` functions will adopt the previously defined aesthetic mapping. The below code generates a plot identical to the above.

```{r multiple geoms 2, eval=F}
merged_energy %>% 
  ggplot(aes(x=datetime, y=large_hydro)) + 
  geom_line(col="turquoise3") + 
  geom_smooth() + 
  labs(title="Hydroelectric (large) generation per hour, Sept 3-9", x="Hour", y="Output (MW)")
```

Usually when we plot multiple geometric objects in one graphic, we are trying to plot the same relationship across different groups in the data. We will explore how this works in the below section on [visualizing grouped data](#groupeddata).

## Other geometric objects

There are many, many more geometric objects that you can create using ggplot. For a full list, see the cheatsheet and reference guide linked above. Several extension packages add even more geometric objects.

# Additional layers

## Labels

We have already seen how we can specify the title and axes labels of a graphic with the `labs()` layer. Note that you can also specify a subtitle and caption for the graphic in the same layer. Let's see this in action using the line plot of imports data we created earlier.

```{r labels}
imports %>%
  ggplot() + 
  geom_line(aes(x=datetime, y=imports), col="red") + 
  labs(title="Energy imports over time in California", subtitle="Hourly data from September 3-9, 2018",
       caption="Source: California Energy Commission",
       x="Hour", y="Amount imported (MW)")
```

For more advanced labeling, you can use the `annotate()` layer, which generates text according to specifications at any point on the coordinate system. See the cheatsheet and reference guide for more details.

## Scales

Scales allow you to manipulate the relationship between data values and aesthetics beyond aesthetic mapping. In other words, they "control the details of how data values are translated to visual properties" (quote from [reference guide](https://ggplot2.tidyverse.org/reference/index.html#section-aesthetics)). You can set the transparency of objects using `scale_alpha` functions, modify color palettes using `scale_color` and `scale_fill` functions, the position of axis markers using `scale_x` and `scale_y` functions, and more. The cheatsheet helpfully organizes scale functions based on the type of task they are suited for, and can see a full list of scale functions in the reference guide.

To see an example at work, let's use the `scale_x_datetime()` function to manipulate the scaling and display of datetime values of the x-axis. Specifically, we will use `date_labels = ` to define which labels to use for the date values and `date_breaks = ` to define how far apart the breaks between the x-axis ticks should be. 

(Note: `%H:%M` means the datetime should be displayed in 24-hour clock format without any date information; you can see a list of datetime conversion specifications in R by looking up `?strptime`.)

```{r scales dates}
imports %>%
  ggplot() + 
  geom_line(aes(x=datetime, y=imports), col="red") + 
  scale_x_datetime(date_labels="%H:%M", date_breaks="12 hours") +
  labs(title="Energy imports over time in California", subtitle="Hourly data from September 3-9, 2018",
       x="Hour", y="Amount imported (MW)")
```

The most common use of scale layers is to specify and adjust color palettes used when plotting grouped data. We will see some examples of this in the [below section on that topic](#groupeddata).

## Themes

### Preset themes

ggplot comes with several preset themes, including:

- `theme_grey()`: this is the default
- `theme_bw()`: strip colors, including grey gradients
- `theme_dark()` and `theme_light()`: these change the backgrounds of the coordinate system
- `theme_minimal()` and `theme_void()`: these are what they sound like. Try them out!

For a full list, see the reference guide file on complete themes (looking up the help file for any of the above functions will open this file).

There are also many ggplot extension packages that provide additional themes. 

### Manually modify theme components

Instead of using a pre-set theme, you can modulate many components of the default theme using the `theme()` function. In this manually controlled theme layer, you can modify many things, including:

- Angle, position, and other characteristics of axis labels (e.g. using `axis.labels.x = element_text()` in the `theme()` function).
- Angle, position, and other characteristics of legends (this is useful when plotting grouped data).
- Characteristics of the background of the plot (e.g. using the `plot.background = ` argument).

For a full list of the components that can be manipulated in the theme layer, see the help file for `ggplot2::theme()`.

## Coordinate system adjustment

A common coordinate system adjustment layer is `coord_flip()`, which rotates the plot such that the `x` and `y` axes are flipped. Let's see an example with the bar chart that we generated with `geom_col()` earlier in the session.

```{r coord_flip}
long_gen %>% 
  mutate(date=lubridate::date(datetime)) %>% 
  group_by(date) %>% 
  summarise(output=sum(output)) %>% 
  ggplot() + 
  geom_col(aes(x=date, y=output)) + 
  labs(title="Total energy generated, by day", x="Day", y="Output (MW)") + 
  coord_flip()
```

You can manipulate the coordinate system in other ways:

- `coord_flip()` is the default Cartesian coordinate system used; by explicitly calling this function, you can change the limits of the `x` and `y` axes from their defaults
- `coord_fixed()` sets a fixed aspect ratio between the `x` and `y` axes
- `coord_transform()` lets you transform the Cartesian coordinates using functions like `sqrt` or `log`
- `coord_polar()` changes the coordinate system to polar coordinates rather than a Cartesian system

## Stats

There are several `stat` functions in ggplot that enable you to conduct statistical transformations of your data prior to plotting. `stat` and `geom` layers can be used interchangeably, as each `stat` layer has a `geom` argument and vice versa. Some reasons that you may want to use a `stat` layer instead of a `geom` layer, or specify the `stat` argument in a `geom` layer include:

- overriding the default setting, e.g. using `stat="identity"` to specify `y` values in `geom_bar()` instead of the default `stat="count"` which uses counts of each `x` value for the y-axis.
- using a transformed version of a variable for aesthetic mapping, e.g. proportions intead of counts in a bar chart.
- drawing attention to statistical transformations in your code.

Since these are relatively rare and more advanced use cases of ggplot, we will not explore them in detail here. If you are interested, see [Chapter 3.7 of the R for data science online textbook](http://r4ds.had.co.nz/data-visualisation.html#statistical-transformations).

# Visualizing grouped data [INCOMPLETE] {#groupeddata}

Throughout these examples, you will see one of the uses of converting data to long-format. Doing so allows us to plot multiple variables in one graphic using a single `geom` function, providing the key column as the grouping variable.

## Colors and fill

Although ggplot will generally interpret a `col = ` argument as providing a grouping variable, it is good practice to specify `group = ` anyway. 

```{r aes colors}

```

Let's take a look at a more complex plot that uses grouping to generate multiple lines. This plot shows the average output of each energy source by hour. Instead of describing the process in detail here, comments are included throughout the code itself. Note how the code for this plot combines several of the topics we have discussed so far (data manipulation before plotting, scales, themes, and labels).

```{r aes colors 2}
long_merged_energy %>% 
  # Create a variable indicating hour only
  mutate(hour=lubridate::hour(datetime)) %>% 
  # Group data by hour and source
  group_by(hour, source) %>% 
  # Compute mean output for each hour-source unit
  summarise(output=mean(output)) %>% 
  # Pipe data into ggplot
  ggplot() + 
  # Plot lines for output over hour, grouped by source
  geom_line(aes(x=hour, y=output, group=source, col=source), size=1) + 
  # Use Set3 color palette to distinguish lines from each other, and give legend a title
  scale_color_brewer(palette="Set3", name="Energy Source") + 
  # Use dark theme to make colors more visible + 
  theme_dark() + 
  # Add labels
  labs(title="Average hourly output by energy source", subtitle="Data collected during Sept 3-9, 2018",
       x="Hour", y="Mean output (MW)")
```

Remember from earlier that we may need to use either `col = ` or `fill = ` depending on the type of geometric object whose appearance we are trying to change. This is the same when we are mapping data to the colors. For example, in order to change the color of the objects in an area plot or bar chart, we will need to use `fill = ` rather than `col = `.

## Position adjustment

```{r pos dodge}

```

```{r pos stack 1}

```

```{r pos stack 2}

```

## Shapes and linetypes

```{r aes shapes}

```

```{r aes linetypes}

```

## Facets

Let's say we are interested in examining hour-by-hour generation data by source. Using the position adjustment skills we learned in the previous subsection, we can generate a line plot as follows.

```{r why facet}
long_merged_energy %>% 
  filter(source!="imports") %>%
  ggplot() + 
  geom_line(aes(x=datetime, y=output, group=source, col=source, position="dodge"), size=1) + 
  labs(title="Generation over time, by energy source", subtitle="Hourly data from September 3-9, 2018", x="Hour", y="Output")
```

```{r facet 1}
long_gen %>% 
  ggplot() + 
  geom_line(aes(x = datetime, y = output)) + 
  facet_wrap(~source)
```

```{r facet 2}
long_gen %>% 
  ggplot() + 
  geom_line(aes(x = datetime, y = output)) + 
  facet_wrap(~source, scales="free") + 
  labs(title="Generation over time, by energy source", subtitle="Hourly data from September 3-9, 2018", x="Hour", y="Output")
```

Using facets also means we can incorporate multiple groupings. 

```{r facet 3}
# Import the regroup data
regroup <- readr::read_csv("data/regroup.csv")
# Begin data preparation
long_gen %>% 
  # Rename "source" variable to "type", to prepare for merging
  rename(type = source) %>%
  # Merge energy generation data with regroup data by "source" variable
  merge(regroup, by = "type") %>% 
  # Pipe data into dplyr
  ggplot() + 
  # Generate lines indicating output ~ time, colored based on "group" variable
  geom_line(aes(x = datetime, y = output, col = group), size=1) + 
  # Adjust color palette for "group" colors and give legend a better name
  scale_color_brewer(palette="Dark2", name="Type of energy source") + 
  # Create facets by source, with free scales
  facet_wrap(~type, scales="free") + 
  # Add labels
  labs(title="Generation over time, by energy source", subtitle="Hourly data from September 3-9, 2018", x="Hour", y="Output") + 
  # Use the minmal theme
  theme_bw() + 
  # Move the legend to the bottom
  theme(legend.position = "bottom")
```

# Final notes

## Comment your code

In some of the examples above, you have seen that we can write comments within a flow of `%>%` or `+` operators. It is highly recommended that you use such comments when doing complex data manipulation or data visualization tasks, or indeed when doing both together. This enables not only others to read your code, but also your own understanding of the code when returning to it at a later time.

## Saving images

Graphics generated using `ggplot2` can be saved as images in three ways:

1. Write the result of the code to a named object, which will live in your environment. You can save objects in your environment to an image as usual. 
2. Once the plot has been generated in the "Plots" tab in the bottom-right pane, you can use the "save" icon in that tab to save the image file. You will be able to change the directory and modify the dimensions of the image when you do this.
3. Use the `ggsave()` function as an additional layer at the end of your code. You must specify the filename when using `ggsave()`, and can additionally specify the filepath (if different from working directory) and dimensions of the image, along with many other settings.

Let's see an example where we combine methods 1 and 3. First, we will save a graphic as an object, and then call the object and add a `ggsave()` layer to create a `.png` file in our directory.

```{r saving images}
# Save a column chart of imports over time
plot_importsovertime <- ggplot(imports) + 
  geom_line(aes(x=datetime, y=imports), col="red") + 
  scale_x_datetime(date_labels="%H:%M", date_breaks="12 hours") +
  labs(title="Energy imports over time in California", subtitle="Hourly data from September 3-9, 2018",
       x="Hour", y="Amount imported (MW)")

# Save the plot as an image
plot_importsovertime + ggsave("importsovertime.png", width=5, height=3)
```
